# Tournament_game, ver 1.0.rus

### авторы: Egor Fomin при содействии beresk_let


# Бойцовский турнир, игра

Игра Tournament_game имитирует турнир между разными бойцами, с возможностью выбирать бойцов из разных списков, создавать своих персонажей, делать ставки на исход боев или турнира. Поединок каждых двух бойцов основан на оригинальной модели боя с нормальным (гауссовым) распределением вероятностей. Пользовательский интерфейс обеспечивает легкую локализацию на иные языки. 

# Ставки

Основной игровой процесс состоит из ставок. После создания (или генерирования случайного) набора бойцов, пользователь может сделать ставку на победителя турнира (коэффициент умножения ставки в случае выигрыша MULTIPLIC\_BET\_TOURN\_WINNER зависит от числа участников), а также делать ставки на победителя в каждом бою на всех этапах проведения турнира. 

Если пользователь проигрывает все средства, его больше не запрашивают о ставках и только последовательно сообщают о результатах всех боев турнира, вплоть до победителя.

## Нарастание сложности:

Чем больше средств на руках у пользователя, тем сложнее делать ставки – все меньше информации пользователь получает о бойцах перед ставкой. 

При самых высоких значениях кассы игрока, информация о бойцах не только сокращается, но и может быть недостоверной (процент недостоверности задается константой UNRELIABLE\_LIMIT). Интервалы изменения объема и достоверности подаваемой информации заданы в константе CASH\_STAGE\_VALUES и ограничены 6 ступенями.

## Таблица рекордов

Если пользователь увеличивает кассу больше, чем у обладателя самого маленького рекорда, он может сам попасть в таблицу рекордов и подниматься в ней, от турнира к турниру, чтобы в итоге занять первое место. 


# Выбор и генерация бойцов турнира: 

При формировании списка бойцов турнира пользователь может задать собственное имя одного, нескольких или всех бойцов и по одному параметру для каждого (или не задавать параметры). 

Также пользователь может воспользоваться готовыми наборами персонажей:

Пользователь выбирает один или несколько из готовых наборов, и программа случайным образом набирает из нее бойцов для турнира. 

Пользователь может создать любое число собственных бойцов и выбрать, из каких наборов будут набраны оставшиеся. Пользователь также может не создавать собственных бойцов вовсе и использовать только готовые наборы. 


## Формирование списка бойцов:

1. пользователь задает общее число бойцов из заданного числа вариантов (MULTIPLIC\_BET\_TOURN\_WINNER), 

2. пользователь выбирает, будет ли создавать своих бойцов – давать им имя по собственному выбору. Если пользователь задает имя, то он может также задать один параметр. Если отказывается задать параметр, они задаются как None и при создании персонажа задаются случайным образом. Если пользователь отказывается задать параметры, пользователю предлагается задать имя следующего бойца. 

3. Как только пользователь отказывается задавать имя, ему предлагается выбрать наборы заданных имен, из которых случайным образом будут отобраны остальные бойцы до заданного числа участников. 

На выходе получаем список из набора для создания персонажа: Имя (name), заданный параметр (parameter\_type), категория величины для заданного параметра (parameter\_base).


# Модель боя (функция fight\_model):

Для обеспечения максимальной скорости расчетов боев в основе лежит простая и изящная модель вычисления результатов ударов бойцов.  

Модель последовательно рассчитывает раунды (функция strike\_model), в которых оба бойца могут нанести удар, а затем обрабатывает его последствия для бойцов. 

Результатом каждого раунда может быть удар одного из бойцов, обоюдный промах или парирование удара. 

За вероятность нанести удар отвечает единственный параметр - duelling. За силу нанесения удара отвечает параметр might, за количество ударов, которые персонаж может выдержать – параметр armor.

## Нанесение удара

Для каждого раунда генерируется единственное случайное число (результат броска - dice) и сопоставляется с единственным параметром каждого бойца – dueling (функция hit\_model).

Попаданием по противнику считается случай, когда результат броска меньше или равен величине duelling бойца. 

Чтобы результат раунда определялся единственным броском, duelling первого бойца отсчитывается от 0 в сторону увеличения, а второго - от 100 в сторону уменьшения. Попаданием первого бойца (hit\_1) считается случай, когда dice меньше или равно показателю duelling, а второго (hit\_2) - больше или равно показателю 100 - duelling. Если оба параметра не дотягивают до значения dice – оба промахнулись (miss). Если оба бойца попали, удар считается парированным – (compensation).

Если оба промахнулись (miss), удар парирован (compensation), или результат равен границе их параметров (kiss), печатает сообщение и не возвращает ничего.

Попадание бойца 1 (параметр duelling 1):

![](https://thumb.cloud.mail.ru/weblink/thumb/xw1/t95V/gUMrmAXZs)

![](https://thumb.cloud.mail.ru/weblink/thumb/xw1/1VHJ/xfkzQQe6s)


Попадание бойца 2 (параметр duelling 2):

![](https://thumb.cloud.mail.ru/weblink/thumb/xw1/C3qi/uKSBL3tTV)

![](https://thumb.cloud.mail.ru/weblink/thumb/xw1/6Vim/GTuNMuz6V)


Удар парирован (compensation):

![](https://thumb.cloud.mail.ru/weblink/thumb/xw1/NhBX/u29mMVfsq)


Оба промахнулись (miss):

![](https://thumb.cloud.mail.ru/weblink/thumb/xw1/QhrC/Cx4YBJoJg)


Для простоты управления моделью, максимальное значение результата броска и параметр duelling задается целыми числами от 0 до 100 (значение DICE\_FIGHT\_LIMIT, файл constants.py), что позволяет осмыслять его как «проценты». 

## Нормальное распределение

Для большей реалистичности результат броска моделируется нормальным (гауссовым) распределением (функция gauss\_dice). Математическое ожидание равно 50 (половина от DICE\_FIGHT\_LIMIT). Т.е. в максимальном числе случаев значение броска будет около 50. Путем анализа большого числа замеров, дисперсия подобрана таким образом, чтобы распределение было достаточно плавным: 

37% результатов с +-10% от половины максимального значения броска (DICE\_FIGHT\_LIMIT, т.е. 50)

66% с +-20% от 50

77% с +-25% от 50

95% c +-40% от 50

т.е. низкие и высокие значения все-таки выпадают не так редко, что все-таки оставляет шанс бойцам с низкими значениями duelling нанести удар.

Значения броска меньше 0 и выше максимального значения (в данном случае DICE\_FIGHT\_LIMIT), отсекаются. 

## Сила нанесения удара

Сила нанесения удара (функция hit\_strength\_model) моделируется простым случайным числом от 0 до величины значения силы бойца (параметр might). Для реалистичности, т.е. воспроизведения ситуации, что человек с определенным навыком, как правило реализует его, а не промахивается или выдает экстраординарный результат с равной вероятностью, сила удара также моделируется тем же нормальным распределением (функция gauss\_dice) с тем же разбросом результатов, только от половины величины might:

37% результатов с +-10% от половины значения might

66% с +-20% от половины значения might

77% с +-25% от половины значения might

95% c +-40% от половины значения might

Таким образом в подавляющем большинстве случаев величина удара составит половину значения might или будет не сильно от него отличаться в меньшую или большую сторону. 

При желании вы можете ввести собственную модель вычисления силы нанесения удара. Например, ввести влияние усталости или последствий ранений и т.п. Если результат можно свести к единственной величине «сила удара», то изменения потребуется вносить только в функцию hit\_strength\_model с добавлением соответствующих атрибутов классу Character, экземпляр которого передается в функцию hit\_strength\_model.


## Наносимый урон (функция damage\_model) 

В настоящем релизе величина урона принимается равной силе удара. 

При желании вы можете ввести собственную модель величины урона. Например, ввести оружие для бойцов с разными параметрами и свойствами поражения. Если результат можно свести к единственной величине урона (damage), то изменения потребуется вносить только в функцию damage\_model.

## Повреждение брони (функция armor\_crush\_model)

В настоящем релизе величина повреждения брони принимается равной величине урона (damage). Урон просто вычитается из текущего значения величины брони (armor\_curr), которая в начале боя равна параметру «armor» и уменьшается с каждым пропущенным ударом. 

При желании вы можете ввести собственную модель величины повреждений. Например, ввести разные виды брони или случайную величину, влияющую на шанс уменьшить урон. Если результат можно свести к единственной величине показателя брони (armor), то изменения потребуется вносить только в функцию armor\_crush\_model.



# Баланс (калибровка)

## Создание параметров бойцов:

Для обеспечения баланса между бойцами, лишь один из параметров может иметь самый высокий показатель, один средний и один низкий. 

Также для баланса, категории величины каждого параметра имеют разные интервалы значений. Поправки к интервалам значений задаются в константе PARAMETERS\_DELTAS. По одной поправке к каждой категории величины, увеличивающий и нижний и верхний предел категории.

Для создания персонажа можно задать не более одного параметра в виде - тип параметра (parameter\_type из PARAMETERS\_DELTAS) и категория величины (parameter\_category из CATEGORIES\_LIMITS). Из набора типа параметров и категорий величины исключаются заданные, остальные распределяются случайным образом. 

Если не задан ни один параметр, все распределение задается случайным образом. Поскольку разные параметры по-разному сказываются на результатах боя, к категориям величины для разных типов параметров используются разные поправки (PARAMETERS\_DELTAS).

## Калибровка значений параметров:

Для калибровки игры, чтобы результат боя был менее предсказуемым и персонажи с низким значением duelling, но высокими значениями силы удара или брони тоже могли выигрывать в значительном числе случаев, максимальное значение параметра duelling ограничено 81. 

В то же время для параметров might и armor введены поправки, увеличивающие и минимальное и максимальное значение в каждой категории величины параметра.

Так, если интервал значений для duelling в категории normal составляет от 41 до 61, то интервал normal для параметра might имеет поправку в 5 единиц и составляет от 46 до 67. А для параметра armor поправку в 10 единиц и составляет от 51 до 61. 

Интервалы значений и поправки задаются в файле constants.py константами:

CATEGORIES\_LIMITS – категории величины

PARAMETERS\_DELTAS – поправки для категорий величины

## Итоговый баланс

В текущем релизе решающее значение для победы персонажа играет высокий параметр duelling. Если у бойца параметр duelling относится к интервалу high и близок к максимальному значению, он с максимальной вероятностью одержит победу.

# Взаимодействие с пользователем. Предусмотренные ошибки ввода

Предусмотрена возможность ввода пользователем различных вариантов ответов на вопросы программы (кортежи ANSWER\_OPTIONS\_YES\_NO\_RUS\_ENG, ENG\_FIRST\_FIGHTER\_OPTIONS, ENG\_SECOND\_FIGHTER\_OPTIONS), в том числе ввод символов в разных регистрах. Например, для просьбы ввести «да» или «нет», пользователь может ввести варианты коротких или длинных ответов, в том числе с ошибочной раскладкой, из кортежа:

```
(
    "да",
    "1",
    "у",
    "lf",
    "fuf",
    "ага",
    "валяй",
    "конечно",
    "давай",
    "ладно",
    "хорошо",
    "yes",
    "ye",
    "y",
    "yeah",
    "yea",
    "yep",
    "yup",
)
```


Предусмотрены различные ответы на ввод пользователем нечитаемого ответа (кортежи ENG\_ERROR\_OPTIONS\_YES\_NO и ENG\_ERROR\_MESSAGES\_FOR\_OPTIONS). После каждого ошибочного ввода программа отвечает следующим вариантом сообщения об ошибке. Когда варианты заканчиваются, выводится каждый раз последний вариант.

Вы можете добавить свои варианты ответов пользователя и сообщений об ошибке.

# Простая локализация

## Переключение между встроенными языками

В настоящий момент в программе предусмотрены два языка общения с пользователем – русский и английский. 

Для переключения языка достаточно изменить единственный переключатель в коде – файл dictionaries.py, переменная choosen\_language. Значение “ENG” для английского и “RUS” для русского языков. 

Все без исключения сообщения пользователю код берет из файла dictionaries.py. Для локализации необходимы изменения только в данном файле. 

## Простая локализация на новый язык:

Код обеспечивает простую локализацию на любой новый язык. Для этого необходимо в файле dictionaries.py:

1. перевести все словари из словаря:
```
    "ENG": {
        "LOCALIZE_DICT": ENGLISH_LOCALIZE_DICT,
        "GENERAL_NAME_LIST": (
            ENG_NAME_LIST_HEROES,
            ENG_NAME_LIST_REAL,
            ENG_NAME_LIST_WALES,
        ),
        "HIGH_SCORES": ENGLISH_HIGH_SCORES,
        "ANSWER_OPTIONS_YES_NO": ANSWER_OPTIONS_YES_NO_RUS_ENG,
        "ERROR_OPTIONS_YES_NO": ENG_ERROR_OPTIONS_YES_NO,
        "ERROR_MESSAGES_FOR_OPTIONS": ENG_ERROR_MESSAGES_FOR_OPTIONS,
        "ROUND_NAMES": ENG_ROUND_NAMES,
        "FIRST_FIGHTER_OPTIONS": ENG_FIRST_FIGHTER_OPTIONS,
        "SECOND_FIGHTER_OPTIONS": ENG_SECOND_FIGHTER_OPTIONS,
        "STRIKE_RESULT_OPTIONS": ENG_STRIKE_RESULT_OPTIONS,
    },
```

2. указать переведенные словари в новом разделе словаря, введя новый ключ (в данном примере "Any new language") в строковом формате, по шаблону:
```    
"Any new language": {
        "LOCALIZE_DICT": None,
        "GENERAL_NAME_LIST": (
            None,
        ),
        "HIGH_SCORES": None,
        "ANSWER_OPTIONS_YES_NO": None,
        "ERROR_OPTIONS_YES_NO": None,
        "ERROR_MESSAGES_FOR_OPTIONS": None,
        "ROUND_NAMES": None,
        "FIRST_FIGHTER_OPTIONS": None,
        "SECOND_FIGHTER_OPTIONS": None,
        "STRIKE_RESULT_OPTIONS": None,
    }
```

3. указать значение переключателя локализации (вашего ключа для словаря DICT\_VARIANT, в данном примере "Any new language") в файле dictionaries.py, переменная choosen\_language в формате:

choosen\_language = "Any new language"

4. Все необходимые для работы кода словари и сообщения будут автоматически сформированы по указанному вами переключателю choosen\_language, как ключу для основного словаря локализации DICT\_VARIANT.

ВАЖНО! 

Код формирует основной словарь сообщений для пользователя (LOCALIZE\_DICT) на основе ключей словаря ENGLISH\_LOCALIZE\_DICT. Поэтому при локализации опирайтесь именно на этот словарь, а также тщательно убедитесь, что всем ключам словаря ENGLISH\_LOCALIZE\_DICT вы дали соответствующую локализацию. 

# Простое расширение игры

## Простота управления наборами бойцов

При формировании списка бойцов пользователю предлагается выбор между наборами из кортежа DICT\_VARIANT[choosen\_language]["GENERAL\_NAME\_LIST"] в файле dictionaries.py. 

Вы можете убрать любой из наборов имен или добавить собственный. Программа автоматически предложит пользователю выбор между теми наборами, что вы оставите.

Добавляйте своих бойцов к существующим наборам или создайте собственный набор.

Списки бойцов турнира (если пользователь не задает все имена сам) формируются случайным образом из отобранных пользователем наборов. 

Список наборов, выбрать из которых предлагается пользователю, находится в кортеже: DICT\_VARIANT[choosen\_language]["GENERAL\_NAME\_LIST"] файла dictionaries.py. 

Каждый набор -  именованный кортеж (namedtuple) структуры: (str[имя списка], (наборы персонажа)). 

Набор персонажа имеет следующую структуру: 

(

index 0 - str[имя], 

index 1 - str[тип заданного параметра (из набора PARAMETERS\_DELTAS)], 

index 2 - str[категория величины заданного параметра]

).

Для каждого персонажа задается только один из типов параметров (parameter\_type) и категорию величины этого параметра (parameter\_base) в строковом формате. Точные значения и значения других параметров будут определены случайным образом. Это обеспечивает некоторый баланс между персонажами разных свойств. 

Для дополнения кортежей собственными героями достаточно либо добавить набор/наборы в имеющиеся кортежи (убедитесь, что кортеж входит в набор словарей данной локализации DICT\_VARIANT[choosen\_language]["GENERAL\_NAME\_LIST"]).

Имя – строковое значение.

Тип заданного параметра – строковое значение строго из числа вариантов в словаре PARAMETERS\_DELTAS. 

Категория величины заданного параметра - строковое значение строго из числа вариантов в словаре CATEGORIES\_LIMITS.

Также можно создать собственный именованный кортеж с наборами персонажей. 

Обязательно включите данный именованный кортеж в набор словарей данной локализации DICT\_VARIANT[choosen\_language]["GENERAL\_NAME\_LIST"]. Тогда при выборе наборов персонажей, пользователю будет предложено выбрать и ваш новый набор. Программа автоматически предлагает пользователю на выбор наборы из данного кортежа. 

## Меняйте таблицу рекордов

Стартовая таблица рекордов хранится в константе DICT\_VARIANT[choosen\_language][" HIGH\_SCORES"] в файле dictionaries.py. 

Вы можете изменить имена в этой таблице, или величину рекордов, или количество имен в таблице. 
ВАЖНО: при выводе на печать выводятся лишь имена с самыми высокими показателями. Количество выводимых пользователю мест определяется константой LEADERBOARD\_LENGTH файла constants.py. Если вы меняете число имен в таблице, или количество мест, выводимых пользователю, обязательно следите, чтобы LEADERBOARD\_LENGTH была меньше или равна количеству мест в изначальной таблице рекордов (HIGH\_SCORES).

## Меняйте боевую модель игры

Вы можете внести свои улучшения процесса боя – изменить модели силы удара, поражающих факторов оружия, повреждения брони персонажей. Для этого надо только расширить имеющиеся отдельные функции в файле fight.py:

hit\_strength\_model

damage\_model

armor\_crush\_model


# Файлы проекта:

**core.py** - Пусковой файл. Содержит стартовый код игры. 

**fight.py** – модель боя. Все функции, обрабатывающие бой между двумя персонажами (экземплярами класса Character). 

**character.py** - Класс персонажа (Character) и функции создания набора бойцов турнира (all\_fighters). 

**moneybox.py** – класс кассы пользователя MoneyBox, и все операции, с нею связанные

**leaderboard.py** – класс таблицы рекордов Standings и операции по внесению в нее пользователя и сортировке

**interactive.py** – все функции, отвечающие за взаимодействие с пользователем – выводящие ему сообщения, или запрашивающие у него данные или решения. 

**perversion.py** – функции придания неполной достоверности информации о персонажах, передаваемых пользователю 

**constants.py** - константы, задающие параметры математической модели боя и игровых ограничений. 

**dictionaries.py** – словари и кортежи со всеми, без исключения сообщениями пользователю. Также набор словарей для локализации (DICT\_VARIANT) и переменная для переключения варианта локализации (choosen\_language).

**tests** (директория) – содержит тесты. В настоящий момент покрытие неполное, раздел дорабатывается. 

### 

ВАЖНО: поскольку исход боя и создание персонажей имеет вероятностный характер, ряд тестов имитирует большое число циклов создания, или ударов или боя. Поэтому запуск полного пакета тестов занимает продолжительное временя и требует значительного объема памяти. Рекомендуется запускать тесты отдельными пакетами. 

ВАЖНО: в настоящий момент тесты выводы информации пользователю настроены на русскую версию локализации.

# Требования

Python 3.9+

Pytest 6.2.5+ для пакета тестов

setuptools 56+
